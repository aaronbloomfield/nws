<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8"><base target="_blank">
    <title>Network Security slide set</title>
    <meta name="description" content="A set of slides for a course on Introduction to Cybersecurity">
    <meta name="author" content="Aaron Bloomfield">
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
    <link rel="stylesheet" href="../slides/reveal.js/dist/reset.css">
    <link rel="stylesheet" href="../slides/reveal.js/dist/reveal.css">
    <link rel="stylesheet" href="../slides/reveal.js/dist/theme/black.css" id="theme">
    <link rel="stylesheet" href="../slides/nws.css">
    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="../slides/reveal.js/plugin/highlight/zenburn.css">
    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? '../slides/reveal.js/css/print/pdf.scss' : '../slides/reveal.js/css/print/paper.scss';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>
    <!--[if lt IE 9]>
  <script src="../slides/reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
  </head>

  <body>
    <div class="reveal">
      <div class="slides">

<section data-markdown id="cover"><script type="text/template">
# CS 4760
&nbsp;  
### Network Security

<p class='titlep'>&nbsp;</p>
<div class="titlesmall"><p>
<a href="http://www.cs.virginia.edu/~asb">Aaron Bloomfield</a> (aaron@virginia.edu)<br>
<a href="http://github.com/aaronbloomfield/ccc">@github</a> | <a href="index.html">&uarr;</a> | <a href="?print-pdf"><img class="print" width="20" src="../slides/images/print-icon.png" style="top:0px;vertical-align:middle"></a>
</p></div>
<p class='titlep'>&nbsp;</p>

## Encryption
</script></section>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<section data-markdown><textarea data-template>
# Contents
&nbsp;  
[Encryption Review](#/review)  
[Key Exchange](#/keyexch)  
[Certificates](#/certificates)  
[SSL & TLS](#/ssltls)  
[Symmetric ciphers](#/symmetric)  
</textarea></section>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

	<section>
      
	  <section data-markdown id="review" class="center"><textarea data-template>
# Encryption Review
	  </textarea></section>
	  
	  <section data-markdown data-separator="^\n\n\n"><textarea data-template>
## Security through obscurity
- The use of secrecy to hide the cryptographic system being used
  - Contrast this with algorithms such as RSA, which are publically analyzed
- The problems is that somebody will figure out how it works ("many eyes make all bugs shallow" - Linus Torvalds)
  - And then, if there is a flaw (due to lack of peer review), the system is vulnerable
- [Reference](http://en.wikipedia.org/wiki/Security_by_obscurity)



<h2 class="r-fit-text">Block-ciphers vs. stream ciphers</h2>

- Block ciphers require a block of text (perhaps 1 Kb, for example)
  - [Reference](http://en.wikipedia.org/wiki/Block_cipher)
- Stream ciphers encrypt data as it is provided, character-by-character
  - I prefer the name 'character cipher' over 'stream cipher'
  - [Reference](http://en.wikipedia.org/wiki/Stream_cipher)



## Cipher Taxonomy
![cipher taxonomy](images/encryption/cipher-taxonomy.webp)
- [Reference](http://en.wikipedia.org/wiki/Ciphers)



## One-time pad (OTP)
- A substitution cipher
- Take a *random* string that is as long as the plain text you want encrypt
  - Use modular arithmetic (or XOR, or Vigenere) to determine the encrypted version
  - Plain text:    helloworld
  - One-time pad: zdxwhtsvtv
  - Encrypted:    hijiwqhnfz
- [Reference](http://en.wikipedia.org/wiki/One-time_pad)



## One-time pad (OTP) analysis
- Pros
  - Proven to be perfectly secure if:
    - the pad is truly random
    - the pad is only used once
    - the pad is kept secret
  - This, it is the ONLY cryptosystem with perfect secrecy
  - It can be performed by hand
- Cons:
  - Good for short messages; it's hard to transport large pads (i.e. network communication)
  - Does not provide message authentication
  - How do you get the pad to the recipient?
    </textarea></section>

    <section>
      <h2>Re-using a one-time pad</h2>
<table class="transparent">
  <tr><td>Use an OTP:&nbsp;</td><td><img alt="re-using OTP" style="vertical-align:middle;display:initial" src="images/encryption/otp-1.webp"> &oplus;
  <img alt="re-using OTP" style="vertical-align:middle;display:initial" src="images/encryption/otp.webp"> =
  <img alt="re-using OTP" style="vertical-align:middle;display:initial;border:2px solid red" src="images/encryption/otp-1e.webp"></td></tr>
  <tr class="fragment"><td>Re-use the<br>same OTP:&nbsp;</td><td><img alt="re-using OTP" style="vertical-align:middle;display:initial" src="images/encryption/otp-2.webp"> &oplus;
  <img alt="re-using OTP" style="vertical-align:middle;display:initial" src="images/encryption/otp.webp"> =
  <img alt="re-using OTP" style="vertical-align:middle;display:initial;border:2px solid blue" src="images/encryption/otp-2e.webp"></td></tr>
<tr class="fragment"><td>Extract<br>the images:&nbsp;</td><td><img alt="re-using OTP" style="vertical-align:middle;display:initial;border:2px solid red" src="images/encryption/otp-1e.webp"> &oplus;
  <img alt="re-using OTP" style="vertical-align:middle;display:initial;border:2px solid blue" src="images/encryption/otp-2e.webp"> =
  <img alt="re-using OTP" style="vertical-align:middle;display:initial" src="images/encryption/otp-ans.webp"></td></tr>
</table>
<p>This example from <a href="https://crypto.stackexchange.com/questions/59/taking-advantage-of-one-time-pad-key-reuse">StackExchange</a></p>
</section>

    <section data-markdown data-separator="^\n\n\n"><textarea data-template>
## Private key cryptography
- The function and/or key to encrypt/decrypt is a secret
 - (Hopefully) only known to the sender and recipient
- The same key encrypts and decrypts
- How do you get the key to the recipient?
- Example algorithms: AES, DES



## Public key cryptography
- Everybody has a key that encrypts and a separate key that decrypts
 - They are not interchangable!
- The encryption key is made public
- The decryption key is kept private
- Example algorithms: RSA, ECDSA



## Public key cryptography goals
- Key generation should be relatively easy
- Encryption should be easy (polynomial time)
- Decryption should be easy (polynomial time)
  - With the right key!
- Cracking should be very hard (exponential time)
- Mathematical concepts need to used where the operations to do the first three are "easy" and the operation to perform the last one is "hard"



## Elliptic curves

<img src='images/encryption/secp256k1-a.svg' class='stretch'>



## Elliptic curves
<img src='images/encryption/secp256k1-e-4points-line.svg' class='stretch'>



## Hard versus Easy Math
- Integer factorization
  - Generating a prime number is (relatively) easy
  - Factoring an integer, when there are not small prime factors, is hard
- Discrete logs
  - Computing $x = a^b\text{ mod }c$ is (relatively) easy
  - Computing $a$ when given $x$, $b$, and $c$, and you know $x = a^b\text{ mod }c$, is hard
- Elliptic curves
  - Adding points together is (relatively) easy
    - Repeated efficient adding yields multiplication of a point by a scalar: $P=d \otimes G$
  - Computing $d$ when you are given $G$ and $P$ and you know $P=d \otimes G$, is hard



## Review: RSA
- Uses prime numbers, integer factorization, and discrete logs
- Key generation:
  - Generate two large primes $p$ and $q$ and compute $n=p \ast q$
  - Choose $1 < e < n$ which is relatively prime to $(p-1)(q-1)$ (65537 is almost always chosen)
  - Compute $d$ such that $d * e \equiv 1 (mod (p-1)(q-1))$
    - That's a discrete log
- Encryption:
  - Put into blocks, padding as necessary
  - Encryption formula is $c = m^e\text{ mod }n$
- Decryption
  - Decryption formula is $p = m^d\text{ mod }n$



<h2><a href="http://xkcd.com/538">Security</a></h2>
<img class="stretch" src="http://imgs.xkcd.com/comics/security.png" title="Actual actual reality: nobody cares about his secrets.  (Also, I would be hard-pressed to find that wrench for $5.)" alt="Security">



<!-- .slide: class="right-float-img-400" -->
## Review: Signatures
[![](https://upload.wikimedia.org/wikipedia/commons/d/d5/JohnHancocksSignature.svg)](https://commons.wikimedia.org/wiki/File:JohnHancocksSignature.svg)
- A signature is not to hide (encrypt) the message
  - Instead, it's to assure someone that the message is what you say it is
- To "sign" a message:
  1. Write a message, and determine the SHA-256 (or similar) hash
  2. Encrypt the hash with your private (encryption) key
  3. Anybody can verify that you created the message because ONLY the public (encryption) key can decrypt the hash
  4. The hash is then verified against the message
- Formally: given message $m$, hash function $h()$, public key encryption $e_{pub}()$ and $e_{pri}()$, the signature is $e_{pri}(h(m))$



<!-- .slide: class="right-float-img-500 no-border" -->
## Review: Randomness: LCG
[![](https://upload.wikimedia.org/wikipedia/commons/1/1c/6sided_dice_%28cropped%29.jpg)](https://commons.wikimedia.org/wiki/File:6sided_dice_(cropped).jpg)
- [Linear congruential generator (LCG)](https://en.wikipedia.org/wiki/Linear_congruential_generator)
- $X_{n+1}=(a*X_n+c) \text{ mod } m$
  - $m$ is the modulus; must be positive
  - $a$ is the multiplier: $0 < a < m$
  - $c$ is the increment: $0 < c < m$
  - $X_0$ is the seed value
- Let $m=9$, $a=4$, $c=7$
- We'll arbitrarily decide to start the sequence at 1: $X_0=1$
- $X_{n+1}=(a*X_n+c) \text{ mod } m$
  - $X_0 = 1$
  - $X_1 = (4*1+7) \text{ mod } 9 = 2$
  - $X_2 = (4*2+7) \text{ mod } 9 = 6$
  - Rest of the sequence: 4, 5, 0, 7, 8, 3, and then back to 1



<!-- .slide: class="right-float-img-600 no-border" -->
## Review: Randomness
[![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/d0/Black_Polyhedral_Game_Dice.jpg/1024px-Black_Polyhedral_Game_Dice.jpg)](https://commons.wikimedia.org/wiki/File:Black_Polyhedral_Game_Dice.jpg)
- To create secure keys, we need a good random number generator
  - Cryptographically Secure Pseudo Random Number Generator (CSPRNG)
- It requires:
  - A good algorithm
  - A good source of randomness (entropy): environmental sensors, timings, etc.
      </textarea></section>

	</section>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<section>

<section data-markdown id="keyexch" class="center">
  <textarea data-template>
# Key Exchange & DHE
  </textarea>
</section>
    
<section data-markdown data-separator="^\n\n\n">
  <textarea data-template>
<!-- .slide: class="right-float-img-600 no-border" -->
## Key Exchange
[![](https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Keys_%284602593426%29.jpg/1024px-Keys_%284602593426%29.jpg)](https://commons.wikimedia.org/wiki/File:Keys_(4602593426).jpg)
- If you want to communicate with another party, how do you create a private key?
  - One solution: Key stores, but only if you both have generated public/private key sets
    - Not always practical for all security protocols
- Another solution: [Diffie–Hellman key exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)
  - This version uses discrete logs
  - A variant called [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman) uses elliptic curves



<!-- .slide: class="right-float-img-500 no-border" -->
## [Diffie Hellman key exchange](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange)
[![](https://upload.wikimedia.org/wikipedia/commons/8/88/Diffie_and_Hellman.jpg)](https://commons.wikimedia.org/wiki/File:Diffie_and_Hellman.jpg)
- Alice and Bob agree on public values *g* (generator) and *p* (prime or modulus)
- Alice picks a private *a* and sends to Bob $A=g^a \mod p$
- Bob picks a private *b* and sends to Alice $B=g^b \mod p$
- Because $g^{ab} \mod p = g^{ba} \mod p$, both can compute the secret key
  - Alice received $g^b \mod p$ and computes $(g^b \mod p)^a \mod p = g^{ab} \mod p$
  - Similarly for Bob



## DH key exchange example
From [Wikipedia](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange#Cryptographic_explanation); <span style="color:skyblue">blue</span> are public, <span style="color:red">red</span> are secret
<ol style="font-size:80%;line-height:110%;">
<li>Alice and Bob agree to use a modulus <i><span style="color:skyblue">p</span></i> = <span style="color:skyblue">23</span> and base <span style="color:skyblue">g</span></i> = <span style="color:skyblue">5</span> (which is a primitive root modulo 23).</li>
<li>Alice chooses a secret integer <i><b><span style="color:red">a</span></b></i> = 4, then sends Bob <i><span style="color:skyblue">A</span></i> = <i><span style="color:skyblue">g</span><sup><b><span style="color:red">a</span></b></sup></i> mod <i><span style="color:skyblue">p</span></i>
<ul><li><i><span style="color:skyblue">A</span></i> = <span style="color:skyblue">5</span><sup><b><span style="color:red">4</span></b></sup> mod <span style="color:skyblue">23</span> = <span style="color:skyblue">4</span></li></ul></li>
<li>Bob chooses a secret integer <i><b><span style="color:red">b</span></b></i> = 3, then sends Alice <i><span style="color:skyblue">B</span></i> = <i><span style="color:skyblue">g</span><sup><b><span style="color:red">b</span></b></sup></i> mod <i><span style="color:skyblue">p</span></i>
<ul><li><i><span style="color:skyblue">B</span></i> = <span style="color:skyblue">5</span><sup><b><span style="color:red">3</span></b></sup> mod <span style="color:skyblue">23</span> = <span style="color:skyblue">10</span></li></ul></li>
<li>Alice computes <i><b><span style="color:red">s</span></b></i> = <i><span style="color:skyblue">B</span><sup><b><span style="color:red">a</span></b></sup></i> mod <i><span style="color:skyblue">p</span></i>
<ul><li><i><b><span style="color:red">s</span></b></i> = <span style="color:skyblue">10</span><sup><b><span style="color:red">4</span></b></sup> mod <span style="color:skyblue">23</span> = <span style="color:red">18</span></li></ul></li>
<li>Bob computes <i><b><span style="color:red">s</span></b></i> = <i><span style="color:skyblue">A</span><sup><b><span style="color:red">b</span></b></sup></i> mod <i><span style="color:skyblue">p</span></i>
<ul><li><i><b><span style="color:red">s</span></b></i> = <span style="color:skyblue">4</span><sup><b><span style="color:red">3</span></b></sup> mod <span style="color:skyblue">23</span> = <span style="color:red">18</span></li></ul></li>
<li>Alice and Bob now share a secret (the number 18)</li>
</ol>



<!-- .slide: class="right-float-img" -->
[![DH key exchange as colors](images/encryption/Diffie-Hellman_Key_Exchange.svg)](https://commons.wikimedia.org/wiki/File:Diffie-Hellman_Key_Exchange.svg)
## DH key<br>exchange<br>example<br>as colors



## Colors in video (at 2:43)
<iframe width="720" height="540" src="https://www.youtube.com/embed/YEBfamv-_do?t=163&rel=0" frameborder="0" allowfullscreen></iframe>

If that doesn't work, try the [direct Youtube link](http://youtu.be/YEBfamv-_do?t=163), but start at 2:43



<h2 class="r-fit-text">DH key exchange in practical use</h2>

- Used in many cryptographic protocols
  - Including ones we will see shortly
- Uses *very* large numbers created with a very good pseudo-random number generator



## MITM versus DH key exchange?
- Possible if Eve actively controls the communication medium
- If s/he is only a *passive* listener, then it is not possible
- How to avoid an active compromiser:
  - Post on a public forum
  - Use communication methods s/he can't compromise, such as shortwave radio
- Recap:
  - It is secure against an *eavesdropper*
    - Even if transmitted in plaintext
  - But *not* against somebody who can modify the messages



## Forward Secrecy (FS)
- Also known as perfect forward secrecy (PFS)
- The concept that a future compromise of keys...
  - ... including the server's private keys...
- Will *not* allow decryption of past sessions
- Solution: generate a unique *session key* for each encrypted connection
  - And discard once done
- Communicating the session key via public key cryptography is *not* forward secret
- But DHE, even in plaintext, is
  </textarea>
</section>

</section>
	
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<section>

<section data-markdown id="certificates" class="center">
  <textarea data-template>
# Certificates
  </textarea>
</section>
    
<section data-markdown data-separator="^\n\n\n">
  <textarea data-template>
## Definition
- A certificate is:
  - A public key
  - Information about the key (algorithm used, version number, etc.)
  - An identity (hostname, individual, etc.)
  - Other meta-data (expiration date, etc.)
  - A *signature* from a *certificate authority*
- Most common format is [X.509](https://en.wikipedia.org/wiki/X.509)



## Diagram of an X.509 cert
![x.509 certificate](images/encryption/x.509-cert.svg)



<!-- .slide: class="right-float-img-1000 no-border" -->
## Certificate usage
[![https certificate](https://upload.wikimedia.org/wikipedia/commons/4/4b/ServerCertificate.png)](https://commons.wikimedia.org/wiki/File:ServerCertificate.png)
- All websites that support https provide such a certificate to any client
- Browsers can display certificate information, such as shown here
- We can view one via our web browser, such as [www.cs.virginia.edu](https://www.cs.virginia.edu/computing)



## Certificate validity
- All certificates are *signed* with the (private) key of a certificate authority (CA)
  - Their public keys are well known, and are hard-coded into browsers
  - Or determined by key exchange protocols discussed in this slide set
- One can verify such a certificate by the (known) public key of the CA
- One can "self sign" a certificate, but modern browsers typically won't allow viewing without manual exceptions



## Certificate Chains

<a href='https://commons.wikimedia.org/wiki/File:Chain_of_trust_v2.svg'><img src='https://upload.wikimedia.org/wikipedia/commons/thumb/8/87/Chain_of_trust_v2.svg/1024px-Chain_of_trust_v2.svg.png' style='width:80%'></a>

An entity (such as virginia.edu) can hold an *intermediate* certificate, which allows it to sign for entities in its division (such as news.virginia.edu)



## Certificate Authorities (CAs)
- By definition, they have a so-called *root* certificate
  - Although it may not be trusted by anybody else
- Any CA can "vouch" (i.e., sign) for *any* certificate
  - For any website or any (likely new) CA
- Thus, the security is based on the weakest CA
- What happens if a CA is compromised or goes rogue?



## CA Revocation
- This has happened!  In February 2018.
  - [Google to kill Symantec certs in Chrome 66, due in early 2018](https://www.theregister.co.uk/2017/09/12/chrome_66_to_reject_symantec_certs/)
  - Firefox also: [Distrust of Symantec TLS Certificates](https://blog.mozilla.org/security/2018/03/12/distrust-symantec-tls-certificates/)
- The reason: a site called [Trustico](https://www.trustico.com/) resold Symantec-signed certificates
  - The 23,000 certificates Trustico sold were "compromised"
    - They still had the private keys (a big no-no)
  - They were sold under the umbrella of Symantec, so Symantec was party at fault as well



## Trusting Trust
- A server's certificate is signed by a Certificate Authority
  - Perhaps through an intermediary certificate
- So we trust the server's certificate because the CA vouches for it
- And we trust the CA because... everybody else does?
- At some point, we have to trust that the system is well designed and that it works



<h2 class="r-fit-text">Root CA hack: DigiNotar (Sept 3, 2011)</h2>

- Dutch certificate authority [DigiNotar](https://en.wikipedia.org/wiki/DigiNotar) suffered a security breach
- Result: ~500 fraudulent certificates issues
- Target: 300k Iranian gmail users
  - Gmail users then compromised via MITM attack
- Whodunit?
  - Dutch government's investigation stated the Iranian gov't was behind it
  - [Bruce Schneier](https://en.wikipedia.org/wiki/Bruce_Schneier) claims it was  "either the work of the NSA, or exploited by the NSA" ([ref](https://www.schneier.com/blog/archives/2013/09/new_nsa_leak_sh.html)); others dispute this
- Result: all DigiNotar certs were blacklisted; company closed a week later



## Root CA Abuse: CNNIC (Apr 2015)
- [China Internet Network Information Center (CNNIC)](https://en.wikipedia.org/wiki/China_Internet_Network_Information_Center) handles domain registry and certificates in China
  - Applied for a trusted root cert to Mozilla in 2009; later to Microsoft
- In 2015, an intermediate CA issued by CNNIC was found to have issued fraudulent certs for Google domains
  - An Egypt-based firm used it to impersonate some Google domains
- Google revoked CNNIC's root certificate
- April 2015: Google & Mozilla announced they were no longer trusting CNNIC's root cert



## Root CA Misuse: WoSign and StartCom (2016/2017)
- WoSign was (is?) China's largest certificaute issuer, owned by [Qihao 360](https://en.wikipedia.org/wiki/Qihoo_360)
  - [StartCom](https://en.wikipedia.org/wiki/StartCom), an Israeli certificate authority, was acquired in secret by WoSign
- WoSign and SmartCom issued "hundreds of certificates with the same serial number in just five days"
  - Including one for GitHub
- Chrome and Mozilla revoked their root certificate recognition in 2017



## Trusted root cert count
- For [Apple devices](https://support.apple.com/en-us/105116): 159 as of Feb 21, 2024
- For [Mozilla / Firefox](https://wiki.mozilla.org/CA/Included_Certificates): 170 as of Feb 21, 2024
- For [Microsoft](https://ccadb.my.salesforce-sites.com/microsoft/IncludedCACertificateReportForMSFT): 487 as of Feb 21, 2024
- Other platforms (Chrome, Android, etc.) only seem to list how to find it on the browser (Chrome) or device (Android)
  </textarea>
</section>

</section>
	
<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

<section>

<section data-markdown id="ssltls" class="center">
  <textarea data-template>
# SSL & TLS
  </textarea>
</section>
    
<section data-markdown data-separator="^\n\n\n">
  <textarea data-template>
## SSL & TLS
- They are cryptographic protocols used to encrypt network communication
- SSL: Secure Sockets Layer
  - v1.0 never released due to flaws
  - v2.0 released in 1995; broken and not used
  - v3.0 released in 1996; broken and not used
- TLS: Transport Layer Security, the successor to SSL
  - v1.0 released Jan 1999; currently deprecated
  - v1.1 released Apr 2006; currently deprecated
  - v1.2 released Aug 2008; in widespread use
  - v1.3 released Aug 2018; currently being adopted



## TLS Usage
- TLS can be implemented on top of just about any protocol
- Most common use: when implemented on top of HTTP, that yields HTTPS
- Also used for encrypting mail (SMTP)
- A programmer can use it for any other purpose



## Public vs. Symmetric Cryptography
- Public key cryptosystems (such as RSA) are:
  - Very secure: one message will take all the computers in the world longer than the life of the universe to crack
  - Very slow: not feasible for real-time data transmission (downloading a large file, streaming, etc.)
- They are typically used for key exchange, and then symmetric key cryptography is used for the rest of the communication



## TLS 1.2 Handshake, part 1
- Client opens a network connection to server
- Client sends *hello*, including a random number $R_c$ and supported ciphers
- Server responds with *hello*, including a random number $R_s$, selection of which client-supported cipher to use, its certificate, and requests client certificate
- Client checks server certificate, and sends its own cert, and a signature of all previous messages sent
  - Signed with the client certificate's private key
- Server checks client certificate and signature



## TLS 1.2 Handshake, part 2
- Client generates $PMS$ (Pre-Master Secret) -- a session key -- and sends it to server, encrypted with server's public key
- Both sides compute $MS$ (Master Secret) from $PMS$, $R_s$, and $R_c$
- Client send a message to switch over to using the $MS$ for symmetric encryption
  - Server confirms switching over to using the $MS$ for encryption
- Both sides terminate the SSL handshake, and use $MS$ as the symmetric encryption key
  </textarea>
</section>

<section><img alt="tls 1.2 protocol" src="images/encryption/SSL_handshake_with_two_way_authentication_with_certificates.svg" class="stretch"><br><a href="https://commons.wikimedia.org/wiki/File:SSL_handshake_with_two_way_authentication_with_certificates.svg">source</a>, <a href='https://upload.wikimedia.org/wikipedia/commons/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg'>bigger</a></section>

<section data-markdown data-separator="^\n\n\n">
  <textarea data-template>
## Is TLS 1.2 forward-secret?



## Is TLS 1.2 forward-secret?
- No, it is not (generally)
- Depending on the ciphers used, if the keys are later made available, then it is *NOT* forward-secret
- Let's review the [TLS 1.2 protocol](https://upload.wikimedia.org/wikipedia/commons/a/ae/SSL_handshake_with_two_way_authentication_with_certificates.svg)
- What would make it forward-secret?
  - Adding in Diffe-Hellman Key Exchange (DHE)



## TLS 1.3
- Cryptographic improvement:
  - Only allow public encryption protocols that are forward-secret (meaning: they use DHE)
- Other improvements:
  - Send more of the information as a single message, so there is less back-and-forth to the handshake
- Speed improvements:
  - Requires less messages



<h2>TLS 1.2 versus TLS 1.3</h2>
<a href='images/graphs/tls-1.2.webp'><img src="images/graphs/tls-1.2.webp" style="float:left;width:300px;margin-right:60px"></a>
<a href='images/graphs/tls-1.3.webp'><img src="images/graphs/tls-1.3.webp" style="float:right;width:300px;margin-left:40px"></a>

- Fewer msgs
- Speed diff: perhaps 200 ms instead of 300 ms



## TLS Ciphers Supported
- In version 1.3, for key exchange, only forward-secret public key systems are supported
  - Mostly RSA variants with a secure DH key exchange
  - Version 1.2 allows many other algorithms
- Once the channel is configured, multiple algorithms are supported, the most common being AES



## [TLS key exchange protocols](https://en.wikipedia.org/wiki/Transport_Layer_Security#Key_exchange_or_key_agreement)

<img alt="TLS key exchange protocols" src="images/encryption/tls-protocols-1.webp" class="stretch">



## [TLS session protocols](https://en.wikipedia.org/wiki/Transport_Layer_Security#Key_exchange_or_key_agreement)

<img alt="TLS session protocols" src="images/encryption/tls-protocols-2.webp" class="stretch">
</textarea>
</section>

<section>
  <h2>Initialization Vectors (IVs)</h2>
  <p>Each successive encrypted block depends on the previous one, so that two encrypted blocks that are the same plaintext will have different ciphertext</p>
<img class="stretch" alt="IVs" src="images/encryption/IVs.svg"></p>
</section>


<section data-markdown data-separator="^\n\n\n">
  <textarea data-template>
## Message authentication code (MAC)
- It's "a short piece of information used to authenticate a message" ([Wikipedia](https://en.wikipedia.org/wiki/Message_authentication_code))
- Like a digital signature, but:
  - uses a shared *secret* key, so it is faster
- Like a hash, but:
  - provides authentication, not just a message digest
  - includes the secret key, so two different connections' MAC of the same text will be different due to different secret keys



## A possible MAC
- Given a message $m$ and a secret key $k$:
  - Create a new value $x = m \cdot k$
	- That's string concatenation
  - Hash that message: $h = hash(x)$
	- Use a good hash function!
  - Encrypt that hash with $k$: $mac = encrypt(h,k)$
    - Likely AES (or similar) with the shared secret key
- In one line: $mac = encrypt(hash(m \cdot k),k)$



## MAC properties
- Does not encrypt the message!
  - If the connection is not encrypted, then the message is eavesdroppable
- Cannot be forged without the secret key
  - Any eavesdropper must know the secret key in order to create a valid MAC
- It is "unforgeable under chosen-message attacks"
  - Even if Eve can get Bob to send chosen text attacks, she needs the (unknown to her) secret key to generate a valid MAC
- Provides authentication (since only the other party has the secret key)



## HMAC
- A MAC is a general term for a message authentication code
- A HMAC uses a hash as its algorithm
- Not all MACs use hashes
  - A CMAC uses a cipher (AES, DES, etc.) to create the code
    - Likely truncating it to the first $x$ bits
- The example algorithm a few slides back was an HMAC
- Named by their hash algorithm:
  - HMAC-MD5, HMAC-SHA1, etc.



<table class="transparent"><tr><td style="vertical-align:middle"><h2>HMAC<br>with<br>SHA1</h2></td><td><a href="https://commons.wikimedia.org/wiki/File:SHAhmac.svg"><img alt="hmac-sha1" src="images/encryption/SHAhmac.svg"></a></td></tr></table>

*i_pad* and *o_pad* have known and non-secret values



## Authenticated Encryption with Associated Data (AEAD)
- MACs do not *encrypt* the data, and we want to do so
- If we combine encryption and a MAC, we get an AEAD
  - Assuming a few properties about the quality of the encryption and MAC function
- The "associated data" is non-encrypted data
- Usage: network packets
  - The payload is encrypted (via authenticated encryption)
  - The packet headers, which cannot always be encrypted, are the "associated data"



## [TLS MAC protocols](https://en.wikipedia.org/wiki/Transport_Layer_Security#Key_exchange_or_key_agreement)
![TLS MAC protocols](images/encryption/tls-protocols-3.webp)
Note that even if the MAC doesn't support encryption (in the first 3 rows), the cipher (likely AES) still does
</textarea>
</section>

</section>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

  <section>
      
    <section data-markdown id="symmetric" class="center"><textarea data-template>
# Symmetric ciphers
    </textarea></section>
    
    <section data-markdown data-separator="^\n\n\n"><textarea data-template>
## Data Encryption Standard ([DES](http://en.wikipedia.org/wiki/Data_Encryption_Standard))
- Adopted in 1976, it's a private-key encryption/decryption block cipher
- Briefly, it does a lot of (invertible) bit-shifting in rounds to encrypt/decrypt a message
- How to crack?
  - It is susceptible to brute force attacks ($2^{56} = 7 * 10^{16}$ keys)
- Solution: use DES three times => "Triple DES"
  - Use a 56*3 = 168 bit key, and encrypt the message three times, once with each key



## Cracking Triple DES encryption
- Brute-force attacks:
  - $2^{168}$ keys, but due to various mathematical properties, this ends up being $2^{112}$ different keys
- "The best attack known on 3-key TDES requires around $2^{32}$ known plaintexts, $2^{113}$ steps, $2^{90}$ single DES encryptions, and $2^{88}$ memory"
- NIST (National Institute of Standards and Technology) considers it secure through 2030



## DES conspiracy theories
- NSA was involved with DES' creation
  - They convinced IBM to lower the key length from 128 to 64, and then to 56
  - And kept many of the details secret
  - Many well-respected people criticized the NSA for "improper interference" with the algorithm
- In 1977, Diffie and Hellman (major names in cryptography) proposed a $20 million machine that could crack a DES message in a single day
- It's known that the NSA had the budget for such a machine.  But did they build it?



<h2 class="r-fit-text">Advanced Encryption Standard (AES)</h2>

- The successor to DES
- Has three possible key lengths: 128, 192, and 256
- NSA approved this standard, and kept the process open
- Like DES, it's a series of (invertible) bit-shifting in rounds to encrypt/decrypt a message
- Many worry about the security of the standard
  - ... that somebody may figure a way to crack it mathematically, in particular
- [Reference](http://en.wikipedia.org/wiki/Advanced_Encryption_Standard)



## AES encryption modes
- Lots of them!
- Ones allowed in TLS 1.3:
  - AES-CBC (Cipher block chaining): provides confidentiality only
  - AES-GCM (Galois/counter mode): provides AEAD



## AES-CBC encryption
![AES-CBC encryption](https://upload.wikimedia.org/wikipedia/commons/8/80/CBC_encryption.svg)
- Formulaicly:
  - $c_0 = AES_e(IV \oplus m_0)$
  - $c_1 = AES_e(c_0 \oplus m_1)$
  - $c_2 = AES_e(c_1 \oplus m_2)$



## AES-CBC decryption
![AES-CBC decryption](https://upload.wikimedia.org/wikipedia/commons/2/2a/CBC_decryption.svg)
- Formulaicly:
  - $m_0 = IV \oplus AES_d(c_0)$
  - $m_1 = c_0 \oplus AES_d(c_1)$
  - $m_2 = c_1 \oplus AES_d(c_2)$



## AEC-CBC pros and cons
- Provides only confidentiality, not integrity or authenticity
- Not parallelizeable
  - Each block depends on the previous one



## Encryption & Hashing Goals
- *Integrity:* the message canʻt be changed, maliciously or accidentally
  - Formally, a change is always detectable
- *Confidentiality:* the message can't be read by somebody else
  - In other words, itʻs encrypted
- *Authenticity:* the message came from who you think it came from
  - Formally, from an entity that has the appropriate key



## Message Authentication Code (MAC)
- Like a digital signature, but with a symmetric key
- Provides the *integrity* and *authenticity* but not *confidentiality*
- $MAC(k,m)$ will produce a short bit string that can only be created with the key $k$ and message $m$
  - Hash-based (HMAC) example: 
    - $HMAC(k,m) = SHA256(k \cdot m)$
    - Named for the algorithm used: HMAC-MD5, HMAC-SHA1, etc.
  - Cipher-based (CMAC) example: 
    - $CMAC(k,m) = AES(k,m).truncate(256)$
    - Also named for the cipher used: CMAC-AES, etc.
  - GMAC uses Galois algorithm from AES-GCM



## Why MACs?
- Provides *integrity*
  - An adversary can change the ciphertext; this change would be detected
- Provides *authenticity*
  - A chosen-message attack cannot succeed (canʻt create the MAC)
- Earlier implementations, with just hashes...
  - Were difficult to get right
  - Very error prone and subject to attacks



## Types of authenticated encryption
- Comparisons: [this paper](https://link.springer.com/content/pdf/10.1007/3-540-44448-3_41.pdf) and [this stackexchange.com posting that summarizes it](https://crypto.stackexchange.com/questions/202/should-we-mac-then-encrypt-or-encrypt-then-mac)




<!-- .slide: class="right-float-img-600" -->
## Encrypt-then-MAC (EtM)
![EtM](https://upload.wikimedia.org/wikipedia/commons/b/b9/Authenticated_Encryption_EtM.png)
- Provides integrity of the cipher text (and thus the plain text)
  - Thus, if the cipher text is modified, the message is ignored, and prevents any potential attacks on the implementation
- MAC can not be used to infer anything about the plaintext



<!-- .slide: class="right-float-img-600" -->
## MAC-then-Encrypt (MtE)
![MtE](https://upload.wikimedia.org/wikipedia/commons/a/ac/Authenticated_Encryption_MtE.png)
- No integrity check of the cipher text, but does for the plain text
- MAC can not be used to infer anything about the plaintext



<!-- .slide: class="right-float-img-600" -->
## Encrypt-and-MAC (E&M)
![E&M](https://upload.wikimedia.org/wikipedia/commons/a/a5/Authenticated_Encryption_EaM.png)
- Also no integrity of the cipher text, but yes on the plain text
- MAC can be used to infer information about the plaintext
  </textarea></section>

  </section>

<!-- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -->

</div>
</div>
<script src="../slides/reveal.js/dist/reveal.js"></script>
<script src="../slides/reveal.js/plugin/zoom/zoom.js"></script>
<script src="../slides/reveal.js/plugin/notes/notes.js"></script>
<script src="../slides/reveal.js/plugin/search/search.js"></script>
<script src="../slides/reveal.js/plugin/markdown/markdown.js"></script>
<script src="../slides/reveal.js/plugin/highlight/highlight.js"></script>
<script src="../slides/reveal.js/plugin/math/math.js"></script>
<script src="settings.js"></script>
</body>
</html>
